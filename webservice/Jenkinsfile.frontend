// webservice/Jenkinsfile.frontend
pipeline {
    agent any
    
    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: '브랜치 이름')
    }

    environment {
        // Jenkins Workspace (빌드/테스트용)
        WORKSPACE_NPM_DIR = "${WORKSPACE}\\webservice\\frontend"
        WORKSPACE_CACHE_DIR = "${WORKSPACE}\\webservice\\frontend\\.npm"
        
        // 환경변수 기반 데이터 경로 (일관성 유지)
        WEBSERVICE_DATA_PATH = 'C:\\deploys\\data\\webservice'
        
        // nginx 배포 경로 (Frontend는 nginx로 직접 서빙)
        NGINX_ROOT = 'C:\\nginx\\html'
        BACKUP_DIR = 'C:\\deploys\\backup\\apps\\webservice\\frontend'
        FRONTEND_URL = 'http://localhost'
    }
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // 현재 체크아웃된 브랜치 확인
                    def currentBranch = bat(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "소스코드 체크아웃 완료 - 현재 브랜치: ${currentBranch}"
                    
                    // 파라미터로 받은 브랜치와 비교
                    if (params.BRANCH) {
                        echo "요청된 브랜치: ${params.BRANCH}"
                        if (currentBranch != params.BRANCH && !currentBranch.endsWith("/${params.BRANCH}")) {
                            echo "경고: 요청된 브랜치와 현재 브랜치가 다를 수 있습니다"
                        }
                    }
                }
            }
        }
        
        stage('Setup Test Environment') {
            steps {
                dir("${env.WORKSPACE_NPM_DIR}") {
                    script {
                        echo "Jenkins Workspace에서 테스트 환경 구축"
                        
                        // Node.js 버전 확인
                        bat 'node --version'
                        bat 'npm --version'
                        
                        echo "Jenkins Workspace 테스트 환경 구축 완료"
                    }
                }
            }
        }
        
        stage('Dependency Check') {
            steps {
                dir("${env.WORKSPACE_NPM_DIR}") {
                    script {
                        // package.json 또는 package-lock.json 변경 감지
                        def packageChanged = bat(
                            script: 'git diff HEAD~1 HEAD --name-only | findstr /C:"package.json" /C:"package-lock.json"',
                            returnStatus: true
                        ) == 0

                        def nodeModulesExists = bat(
                            script: 'if exist node_modules (exit 0) else (exit 1)',
                            returnStatus: true
                        ) == 0
                        
                        if (packageChanged || !nodeModulesExists) {
                            echo "패키지 파일 변경 감지됨 또는 node_modules 없음 - 오프라인 번들 설치 실행"

                            // 폐쇄망 환경 - node_modules 번들 압축 해제 방식
                            echo "node_modules 오프라인 번들 설치 중..."
                            bat """
                            chcp 65001 >NUL
                            powershell -NoLogo -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command "\$lockHash = (Get-FileHash 'package-lock.json' -Algorithm SHA256).Hash.Substring(0, 8); Write-Host ('Package-lock hash: ' + \$lockHash); \$bundleFile = 'C:\\deploys\\packages\\frontend\\node_modules\\node_modules_' + \$lockHash + '.zip'; if (Test-Path \$bundleFile) { Write-Host 'Valid node_modules bundle found'; if (Test-Path 'node_modules') { Remove-Item -Recurse -Force 'node_modules' }; Expand-Archive -Path \$bundleFile -DestinationPath '.' -Force; Write-Host 'node_modules extraction complete' } else { Write-Host ('ERROR: node_modules bundle not found: ' + \$bundleFile); Write-Host 'Air-gapped environment requires pre-generated bundle from Download-All-Dependencies.ps1'; exit 1 }"
                            """
                            echo "node_modules 오프라인 번들 설치 완료"
                        } else {
                            echo "패키지 변경 없음 - 기존 node_modules 사용 (폐쇄망 최적)"
                        }
                        
                        // node_modules 설치 검증
                        def nodeModulesVerified = bat(
                            script: 'if exist node_modules (exit 0) else (exit 1)',
                            returnStatus: true
                        ) == 0
                        
                        if (!nodeModulesVerified) {
                            error("의존성 설치 실패: node_modules 폴더가 생성되지 않았습니다")
                        }
                        
                        echo "의존성 설치 완료"
                    }
                }
            }
        }
        
        stage('Lint & Type Check') {
            steps {
                dir("${env.WORKSPACE_NPM_DIR}") {
                    script {
                        // eslint 실행 가능 여부 확인
                        def eslintExists = bat(
                            script: 'if exist node_modules\\.bin\\eslint.cmd (exit 0) else (exit 1)',
                            returnStatus: true
                        ) == 0

                        if (!eslintExists) {
                            echo "eslint가 설치되지 않음 - 오프라인 번들 재설치 시도"
                            bat """
                            chcp 65001 >NUL
                            powershell -NoLogo -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command "\$lockHash = (Get-FileHash 'package-lock.json' -Algorithm SHA256).Hash.Substring(0, 8); \$bundleFile = 'C:\\deploys\\packages\\frontend\\node_modules\\node_modules_' + \$lockHash + '.zip'; if (Test-Path \$bundleFile) { if (Test-Path 'node_modules') { Remove-Item -Recurse -Force 'node_modules' }; Expand-Archive -Path \$bundleFile -DestinationPath '.' -Force; Write-Host 'node_modules reinstalled for eslint issue' }"
                            """
                        }

                        // package.json scripts를 사용하여 eslint 실행 (폐쇄망 환경 호환)
                        bat 'npm run lint'
                    }
                    // TypeScript 타입 체크 (있는 경우)
                    script {
                        def tsconfigExists = bat(
                            script: 'if exist tsconfig.json echo found',
                            returnStdout: true
                        ).contains('found')
                        
                        if (tsconfigExists) {
                            bat 'npm run type-check'
                            echo "TypeScript 타입 체크 완료"
                        }
                    }
                    echo "코드 품질 검사 완료"
                }
            }
        }
        
        stage('Test') {
            steps {
                dir("${env.WORKSPACE_NPM_DIR}") {
                    bat 'npm run test -- --run --reporter=verbose'
                    echo "프론트엔드 테스트 완료"
                }
            }
        }
        
        stage('Create Backup') {
            steps {
                script {
                    // 현재 nginx 파일들을 중앙화된 백업 디렉토리에 백업
                    bat """
                        if not exist "${env.BACKUP_DIR}" mkdir "${env.BACKUP_DIR}"
                        if exist "${env.NGINX_ROOT}\\*" (
                            powershell -Command "Remove-Item -Path '${env.BACKUP_DIR}\\*' -Recurse -Force -ErrorAction SilentlyContinue"
                            powershell -Command "Copy-Item -Path '${env.NGINX_ROOT}\\*' -Destination '${env.BACKUP_DIR}' -Recurse -Force -ErrorAction SilentlyContinue"
                        )
                    """
                    echo "기존 웹 파일을 중앙화된 백업 디렉토리에 백업 완료"
                }
            }
        }
        
        stage('Build') {
            steps {
                dir("${env.WORKSPACE_NPM_DIR}") {
                    script {
                        try {
                            // 파라미터로 전달받은 브랜치 이름 사용
                            def branchName = params.BRANCH ?: env.BRANCH_NAME ?: 'unknown'
                            
                            // 브랜치 이름 검증
                            if (branchName == 'unknown' || branchName == 'null') {
                                echo "경고: 브랜치 이름이 전달되지 않았습니다. Git에서 직접 확인합니다."
                                branchName = bat(
                                    script: 'git rev-parse --abbrev-ref HEAD',
                                    returnStdout: true
                                ).trim()
                            }
                            
                            // 슬래시를 언더스코어로 변환 (경로 안전성)
                            def safeBranchName = branchName.replace('/', '_')
                            
                            // 브랜치별 base path 결정
                            def basePath = (branchName == 'main') ? 
                                '/' : "/tests/${safeBranchName}/"
                            
                            echo "브랜치 '${branchName}' (안전한 이름: '${safeBranchName}')에 대한 base path: ${basePath}"
                            
                            // 브랜치별 빌드 명령 실행
                            if (basePath == '/') {
                                bat 'npm run build'
                                echo "React 빌드 완료 (루트 경로) - Jenkins Workspace"
                            } else {
                                bat "npm run build -- --base=\"${basePath}\""
                                echo "React 빌드 완료 (서브디렉터리: ${basePath}) - Jenkins Workspace"
                            }
                            
                            // 빌드 결과 검증
                            def distExists = bat(
                                script: 'if exist dist\\index.html echo found',
                                returnStdout: true
                            ).contains('found')
                            
                            if (!distExists) {
                                error("빌드 실패: dist/index.html이 생성되지 않았습니다")
                            }
                            
                            // zip 파일 생성 (상위 디렉토리에)
                            powershell 'Compress-Archive -Path .\\dist\\* -DestinationPath ..\\frontend.zip -Force'
                            echo "빌드 패키징 완료 (Jenkins Workspace)"
                            
                        } catch (Exception e) {
                            echo "빌드 실패: ${e.getMessage()}"
                            throw e
                        }
                    }
                }
            }
        }
        
        stage('Deploy') {
            when { 
                expression { 
                    def branch = params.BRANCH ?: env.BRANCH_NAME ?: 'unknown'
                    return branch == 'main' || branch.endsWith('/main')
                }
            }
            steps {
                script {
                    try {
                        // Jenkins Workspace에서 빌드된 zip 파일을 nginx로 배포
                        powershell """
                            # 기존 파일 제거 (백업 제외)
                            if (Test-Path '${env.NGINX_ROOT}') {
                                Get-ChildItem -Path '${env.NGINX_ROOT}' -Exclude 'backup' | Remove-Item -Recurse -Force
                            }
                            
                            # Jenkins Workspace에서 빌드된 zip 파일 배포
                            Expand-Archive -Path '${env.WORKSPACE}\\webservice\\frontend.zip' -DestinationPath '${env.NGINX_ROOT}' -Force
                            Write-Host "프론트엔드 배포 완료 (Jenkins Workspace → nginx)"
                        """
                        
                    } catch (Exception e) {
                        echo "배포 실패: ${e.getMessage()}"
                        // 중앙화된 백업에서 롤백 시도
                        powershell """
                            if (Test-Path "${env.BACKUP_DIR}\\*") {
                                Write-Host "중앙화된 백업에서 롤백 실행 중..."
                                Remove-Item -Path '${env.NGINX_ROOT}\\*' -Recurse -Force -ErrorAction SilentlyContinue
                                Copy-Item -Path '${env.BACKUP_DIR}\\*' -Destination '${env.NGINX_ROOT}' -Recurse -Force
                                Write-Host "롤백 완료"
                            }
                        """
                        throw e
                    }
                }
            }
        }
        
        stage('Deployment Verification') {
            steps {
                script {
                    // 정적 파일 서빙 확인
                    sleep(time: 5, unit: 'SECONDS')
                    
                    def verificationPassed = false
                    for (int i = 0; i < 3; i++) {
                        try {
                            // PowerShell을 사용한 HTTP 요청 확인 (Windows 호환)
                            def response = powershell(
                                script: """
                                    try {
                                        \$response = Invoke-WebRequest -Uri 'http://localhost' -Method GET -TimeoutSec 10 -ErrorAction Stop
                                        Write-Output \$response.StatusCode
                                    } catch {
                                        Write-Output "ERROR"
                                    }
                                """,
                                returnStdout: true
                            ).trim()
                            
                            if (response == "200") {
                                verificationPassed = true
                                echo "배포 검증 성공 (${i+1}번째 시도)"
                                break
                            } else {
                                echo "배포 검증 실패 - HTTP ${response} (${i+1}번째 시도)"
                            }
                        } catch (Exception e) {
                            echo "배포 검증 오류: ${e.getMessage()} (${i+1}번째 시도)"
                        }
                        
                        if (i < 2) sleep(time: 3, unit: 'SECONDS')
                    }
                    
                    if (!verificationPassed) {
                        echo "경고: 배포 검증 실패 - 수동으로 확인이 필요합니다"
                    } else {
                        echo "배포 검증 완료 - 정적 파일이 정상적으로 서빙되고 있습니다"
                    }
                }
            }
        }
        
        stage('Environment Validation') {
            steps {
                script {
                    // 환경변수 기반 경로 검증 (백엔드와 일관성 유지)
                    powershell """
                        Write-Host "환경변수 기반 경로 설정 검증:"
                        Write-Host "WEBSERVICE_DATA_PATH: ${env.WEBSERVICE_DATA_PATH}"
                        
                        if (Test-Path "${env.WEBSERVICE_DATA_PATH}") {
                            Write-Host "데이터 경로 접근 가능: ${env.WEBSERVICE_DATA_PATH}"
                        } else {
                            Write-Host "경고: 데이터 경로가 존재하지 않습니다: ${env.WEBSERVICE_DATA_PATH}"
                            Write-Host "백엔드 API 연동 시 문제가 발생할 수 있습니다."
                        }
                    """
                    echo "환경변수 검증 완료"
                }
            }
        }
        
        stage('Archive Artifact') {
            steps {
                archiveArtifacts artifacts: "webservice/frontend.zip", followSymlinks: false
                echo "Jenkins Workspace에서 빌드된 아티팩트 보관 완료"
            }
        }
    }
    
    post {
        success {
            echo "Webservice Frontend 배포 성공"
        }
        failure {
            echo "Webservice Frontend 배포 실패 - 로그를 확인하세요"
        }
        always {
            // Jenkins Workspace 정리 (폐쇄망 환경 고려)
            dir("${env.WORKSPACE_NPM_DIR}") {
                // 임시 파일 정리만 수행 (node_modules는 보존)
                bat 'if exist "*.tmp" del /f /q *.tmp'
                bat 'if exist "*.log" del /f /q *.log'
                echo "정리 완료 (node_modules 보존 - 폐쇄망 환경)"
            }
        }
    }
}